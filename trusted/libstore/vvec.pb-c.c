/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: vvec.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "vvec.pb-c.h"
void version__init(Version *message) {
  static const Version init_value = VERSION__INIT;
  *message = init_value;
}
size_t version__get_packed_size(const Version *message) {
  assert(message->base.descriptor == &version__descriptor);
  return protobuf_c_message_get_packed_size(
      (const ProtobufCMessage *)(message));
}
size_t version__pack(const Version *message, uint8_t *out) {
  assert(message->base.descriptor == &version__descriptor);
  return protobuf_c_message_pack((const ProtobufCMessage *)message, out);
}
size_t version__pack_to_buffer(const Version *message,
                               ProtobufCBuffer *buffer) {
  assert(message->base.descriptor == &version__descriptor);
  return protobuf_c_message_pack_to_buffer((const ProtobufCMessage *)message,
                                           buffer);
}
Version *version__unpack(ProtobufCAllocator *allocator, size_t len,
                         const uint8_t *data) {
  return (Version *)protobuf_c_message_unpack(&version__descriptor, allocator,
                                              len, data);
}
void version__free_unpacked(Version *message, ProtobufCAllocator *allocator) {
  if (!message)
    return;
  assert(message->base.descriptor == &version__descriptor);
  protobuf_c_message_free_unpacked((ProtobufCMessage *)message, allocator);
}
void version_vector__init(VersionVector *message) {
  static const VersionVector init_value = VERSION_VECTOR__INIT;
  *message = init_value;
}
size_t version_vector__get_packed_size(const VersionVector *message) {
  assert(message->base.descriptor == &version_vector__descriptor);
  return protobuf_c_message_get_packed_size(
      (const ProtobufCMessage *)(message));
}
size_t version_vector__pack(const VersionVector *message, uint8_t *out) {
  assert(message->base.descriptor == &version_vector__descriptor);
  return protobuf_c_message_pack((const ProtobufCMessage *)message, out);
}
size_t version_vector__pack_to_buffer(const VersionVector *message,
                                      ProtobufCBuffer *buffer) {
  assert(message->base.descriptor == &version_vector__descriptor);
  return protobuf_c_message_pack_to_buffer((const ProtobufCMessage *)message,
                                           buffer);
}
VersionVector *version_vector__unpack(ProtobufCAllocator *allocator, size_t len,
                                      const uint8_t *data) {
  return (VersionVector *)protobuf_c_message_unpack(&version_vector__descriptor,
                                                    allocator, len, data);
}
void version_vector__free_unpacked(VersionVector *message,
                                   ProtobufCAllocator *allocator) {
  if (!message)
    return;
  assert(message->base.descriptor == &version_vector__descriptor);
  protobuf_c_message_free_unpacked((ProtobufCMessage *)message, allocator);
}
static const ProtobufCFieldDescriptor version__field_descriptors[2] = {
    {
        "uid", 1, PROTOBUF_C_LABEL_REQUIRED, PROTOBUF_C_TYPE_UINT64,
        0,                                     /* quantifier_offset */
        offsetof(Version, uid), NULL, NULL, 0, /* flags */
        0, NULL, NULL                          /* reserved1,reserved2, etc */
    },
    {
        "ts", 2, PROTOBUF_C_LABEL_REQUIRED, PROTOBUF_C_TYPE_UINT64,
        0,                                    /* quantifier_offset */
        offsetof(Version, ts), NULL, NULL, 0, /* flags */
        0, NULL, NULL                         /* reserved1,reserved2, etc */
    },
};
static const unsigned version__field_indices_by_name[] = {
    1, /* field[1] = ts */
    0, /* field[0] = uid */
};
static const ProtobufCIntRange version__number_ranges[1 + 1] = {{1, 0}, {0, 2}};
const ProtobufCMessageDescriptor version__descriptor = {
    PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
    "version",
    "Version",
    "Version",
    "",
    sizeof(Version),
    2,
    version__field_descriptors,
    version__field_indices_by_name,
    1,
    version__number_ranges,
    (ProtobufCMessageInit)version__init,
    NULL,
    NULL,
    NULL /* reserved[123] */
};
static const ProtobufCFieldDescriptor version_vector__field_descriptors[1] = {
    {
        "versions", 1, PROTOBUF_C_LABEL_REPEATED, PROTOBUF_C_TYPE_MESSAGE,
        offsetof(VersionVector, n_versions), offsetof(VersionVector, versions),
        &version__descriptor, NULL, 0, /* flags */
        0, NULL, NULL                  /* reserved1,reserved2, etc */
    },
};
static const unsigned version_vector__field_indices_by_name[] = {
    0, /* field[0] = versions */
};
static const ProtobufCIntRange version_vector__number_ranges[1 + 1] = {{1, 0},
                                                                       {0, 1}};
const ProtobufCMessageDescriptor version_vector__descriptor = {
    PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
    "version_vector",
    "VersionVector",
    "VersionVector",
    "",
    sizeof(VersionVector),
    1,
    version_vector__field_descriptors,
    version_vector__field_indices_by_name,
    1,
    version_vector__number_ranges,
    (ProtobufCMessageInit)version_vector__init,
    NULL,
    NULL,
    NULL /* reserved[123] */
};
